# 2. MySQL 설치
커뮤니티에서 설치하고 MySQL Server, MySQL Shell, MySQL Router 설치

## MySQL 접속
접속하기 위해 MySQL Shell을 실행시키고
`\sql`을 치면 sql 모드로 들어간다

이 상태에서 바로 sql 문을 쓰면 접속이 안돼있기 때문에 `\connect root@localhost` 로  접속을 해줘야한다

## 환경변수 추가
시스템 환경변수 편집에서 `PATH`환경변수에 `C:\Program Files\MySQL\MySQL Server 8.0\bin` 를 추가한다.
그 후에 mysql 명령어가 통한다.
## 정적 변수와 동적 변수
```mysql
 MySQL  localhost:33060+ ssl  SQL > SHOW GLOBAL VARIABLES LIKE '%max_connections%';
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| max_connections        | 151   |
| mysqlx_max_connections | 100   |
+------------------------+-------+

 MySQL  localhost:33060+ ssl  SQL > SET GLOBAL max_connections=500;
Query OK, 0 rows affected (0.0004 sec)

 MySQL  localhost:33060+ ssl  SQL > SHOW GLOBAL VARIABLES LIKE '%max_connections%' ;
+------------------------+-------+
| Variable_name          | Value |
+------------------------+-------+
| max_connections        | 500   |
| mysqlx_max_connections | 100   |
+------------------------+-------+
```

SET 명령어를 통해 변하는 인자는 MySQL 의 설정파일인 my.cnf 나 my.ini 파일에 반영되는 것은 아이고 현재 기동중인 MySQL 인스턴스에만 유효

MySQL 서버를 재시작했을 때도 적용하려면 my.cnf 파일을 변경해야 한다.
my.cnf 경로 : ` mysql --verbose --help | grep -A 1 "Default options"`

# 4. 아키텍쳐
MySQL 은 대부분의 프로그래밍 언어로부터 접근 방법을 모두 지원한다.
## 4.1 MySQL 엔진 아키텍처

### 4.1.1 MySQL 구조
![아키텍처](./image/mysql_architacture.png)
#### 4.1.1.1 MySQL 엔진
1. 커넥션 핸들러 : 클라이언트로부터의 접속, 쿼리 요청 처리
2. SQL파서 : SQL문이 올바른지 확인
3. 전처리기 : 쿼리 안에 포함된 테이블 이름, 함수 등이 실제 존재하는지, 권한이 있는지 확인
4. 옵티마이저 : 쿼리의 최적화된 실행
#### 4.1.1.2 스토리지 엔진
- 실제 데이터를 디스크 스토리지에 저장, 디스크 스토리지부터 데이터를 읽어오는 것 담당
- MySQL 서버에서 MySQL 엔진은 하나지만 스토리지 엔진은 여러개 사용할 수 있다.
```sql
CREATE TABLE test_table (fd1 INT, fd2 INT) ENGINE=INNODB;
```
- 해당 테이블의 스토리지 엔진은 INNODB로 처리
- 각 스토리지 엔진은 성능 향상을 위해 키 캐시(MyIASM) 이나 InnoDB버퍼 풀(InnoDB)같은 기능 내장
#### 4.1.1.3 핸들러 API
- **핸들러 요청** : MySQL 쿼리 실행기에서 데이터를 쓰거나 읽어야 할 때 각 스토리지 엔진에 요청하는 읽기나 쓰기 요청
- **핸들러 API** : 핸들러 요청에 사용하는 API
- 데이터 작업의 횟수를 `SHOW GLOBAL STATUS LIKE 'Handler%';` 명령으로 확인 가능

### 4.1.2 스레딩 구조
![스레딩](./image/mysql_threading.png)
- MySQL 서버는 **스레드 기반**으로 동작
- 크게 포그라운드 스레드와 백그라운드 스레드로 구분
- 스레드의 목록은 다음의 명령어로 실행 가능
    ``` sql
    SELECT thread_id, name, type, processlist_user, processlist_host
    FROM performance_schema.threads ORDER BY type, thread_id;
    ```
  - 사용자의 요청을 처리하는 스레드: 
    `|        29 | thread/mysqlx/worker                        | FOREGROUND | root             | localhost        |`
  - 3개만 포그라운드 스레드이고 나머지는 백그라운드 스레드
  - 동일한 이름의 스레드가 2개 이상씩 보이는 것은 MySQL 서버의 설정 내용에 의해 여러 스레드가 동일 작업을 병렬 처리하는것
#### 4.1.2.1 포그라운드 스레드(클라이언트 스레드)
- 최소한 MySQL 서버에 접속된 클라이언트 수만큼 존재
- 각 클라이언트 사용자가 요청하는 쿼리 문장 처리
- 클라이언트 사용자가 작업을 마치고 커넥션을 종료하면 해당 커낵션 담당하는 스레드는 스레드 캐시로 되돌아감
  - 이미 스레드 캐시에 일정 개수 이상의 스레드 캐시가 있으면 스레드 캐시에 넣지 않고 스레드를 종료시켜 일정 개수의 스레드만 스레드 캐시에 존재해야 한다
    - 스레드 캐시에 유지할 수 있는 최대 스레드 개수는 `thread_cache_size` 시슽넴 변수로 설정
- 포그라운드 스레드는 MySQL의 데이터 버퍼나 캐시로부터 데이터를 가져온다.
- 버퍼나 캐시에 없는 경우 직접 디스크의 데이터난 인덱스 파일로부터 데이터를 읽어와서 작업 처리
  - **MyISAM 테이블**은 디스크 쓰기 작업을 포그라운드 스레드가 처리함 (지연된 쓰기가 있지만 일반적이진 않음)
  - **InnoDB 테이블**은 데이터 버퍼나 캐시까지만 포그라운드 스레드가 처리하고 디스크 기록작업은 백그라운드 스레드가 처리
#### 4.1.2.2 백그라운드 스레드
- MyISAM 에는 해당사항 크게 X
- InnoDB 에는 여러가지가 백그라운드로 처리
  1. 인서트 버퍼 병합 스레드
  2. **로그를 디스크로 기록하는 스레드**(로그 스레드)
  3. **InnoDB 버퍼 풀의 데이터를 디스크에 기록하는 스레드**(쓰기 스레드)
  4. 데이터를 버퍼로 읽어오는 스레드
  5. 잠금이나 데드락을 모니터링하는 스레드
- MySQL 버전 5.5부터 데이터 쓰기 스레드와 데이터 읽기 스레드 개수를 2개 이상 지정할 수 있음
  - `innodb_write_io_threads`와 `innodb_read_id_threads` 시스템 변수로 스레드 개수 설정
- InnoDB 에서도 데이터를 읽는 작업은 주로 클라이언트 스레드에서 처리되어 읽기 스레드는 많이 설정할 필요 없음
  - 클라이언트 스레드가 직접 처리하기 때문에 백그라운드 읽기 스레드의 증가가 `SELECT`의 성능이 좋아지지 않음
- 쓰기 스레드는 아주 많은 작업을 백그라운드로 처리하기 때문에 일반적인 내장디스크는 2~4정도, DAS나 SAN 스토리지를 사용하는 경우 디스크를 최적으로 사용할 수 있을 만큼 충분히 할당
  - 대형 스토리지는 수백개의 쓰기 요청을 동시에 병렬 처리할 수 기 때문에 고성능스토리지일수록 쓰기 스레드를 올려야 성능이 좋아진다
- 사용자의 요청을 처리하는 도중 데이터 쓰기작업은 지연되어 처리 가능
- BUT! 데이터의 읽기 작업은 절대 지연될 수 없음
- 대부분의 DBMS는 쓰기 버퍼링을 지원해 일괄 처리하는 기능이 있는데
- InnoDB에서 INSERT, UPDATE, DELETE 쿼리로 데이터가 변경되는 경우 데이터가 디스크의 데이터 파일로 완전히 저장될 때 까지 기다리지 않아도 됨
- MyISAM 는 사용자 스레드가 쓰기 작업까지 함께 처리해서 일반적인 쿼리는 쓰기 버퍼링 기능을 사용할 수 없다. 
### 4.1.3 메모리 할당 및 사용 구조
- MySQL 에서 사용되는 메모리 공간은 크게 글로벌 메모리 영역과 로컬 메모리 영역으로 구분됨
- 글로벌 메모리 영역의 모든 메모리 공간은 MySQL 서버가 시작되면서 운영체제로부터 할당된다.
  - 운영체제의 종류에 따라 요청된 메모리 공간을 100% 할당할 수 있고 공간만큼 예약해두고 필요할 때 조금씩 할당하는 경우도 있음
  - 운영체제별 메모리 할당방식이 복잡하고 MySQL 서버가 사용하는 정확한 메모리 양을 측정하는 것이 쉽지 않기 때문에
    - 단순하게 MySQL 시스템 변수로 설정해둔 만큼 운영체제로부터 할당 받는다
#### 4.1.3.1 글로벌 메모리 영역
- 일반적으로 클라이언트 스레드 수와 무관하게 하나의 메모리 공간만 할당된다.
  - 필요에 따라 2개 이상의 메모리 공간 할당 가능
  - 클라이언트 스레드 수와는 무관
  - 글로벌 영역이 N개여도 모든 스레드에 의해 공유
1. 테이블 캐시
2. InnoDB 버퍼 풀
3. InnoDB 어댑티브 해시 인덱스
4. InnoDB 리두 로그 버퍼

#### 4.1.3.2 로컬 메모리 영역
- **세션 메모리 영역**, **클라이언트 메모리 공간**으로도 불린다.
- MySQL 서버 상에 존재하는 클라이언트 스레드가 쿼리를 처리하는데 사용하는 메모리 영역
- 클라이언트가 MySQL 서버에 접속하면 MySQL서버에서는 클라이언트 커넥션으로부터의 요청을 처리하기 위해 스레드를 하나씩 할당
  - 클라이언트 스레드가 사용하는 메모리 공간
  - 클라이언트와 MySQL 서버와의 커넥션을 세션이라고 하기에 로컬 메모리 영역을 세션 메모리 영역이라고 표현
- 각 클라이언트 스레드별로 독립적으로 할당되며 절대 공유되어 사용되지 않는다
- 일반적으로 글로벌 메모리 영역의 크기는 주의해서 설정하는데
- 쇼트 버퍼와 같은 로컬 메모리 영역은 크게 신경쓰지 않고 설정함
  - 최악의 경우 MySQL 서버가 메모리 부족으로 멈춰버릴 수 있어서 **적절한 메모리 공간**을 설정하는 것이 중요하다
- 중요한 특징으로 쿼리의 용도별로 필요할 때만 공간이 할당되고 필요하지 않은 경우 MySQL이 아예 할당을 하지 않을수도 있음
  - 쇼트버퍼나 조인버퍼가 이에 해당
- 커넥션이 열려있는 동안 계속 할당된 상태로 남아있는 공간(커넥션 버퍼나 결과 버퍼)도 있고 쿼리를 실행하는 순간에만 할당하고 다시 해제하는 공간(쇼트 버퍼, 조인 버퍼)도 있다