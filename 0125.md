### 4.1.9 이어서
- 스케쥴링 과정에서 CPU 시간을 제대로 확보하지 못하는 경우 쿼리 처리가 더 느려질 수 있음
- 제한된 수의 스레드만으로 CPU 가 처리하도록 적절히 유도한다면 
  - CPU 프로세서 친화도를 높이고
  - 불필요한 컨텍스트 스위칭을 줄여 오버헤드를 낮출 수 있다
- Percona Server 의 스레드 풀은 기본적으로 CPU 코어의 개수만큼 스레드 그룹을 생성
- 스레드 그룹의 개수는 `thread_pool_size`를 변경해 조절할 수 있다.
- 일반적으로 CPU 코어의 개수를 맞추는게 CPU 친화도를 높이는데 더 좋음
- MySQL 서버가 처리해야 할 요청이 생기면 스레드 풀로 처리를 이관
  - 스레드 풀이 처리중인 작업이 있는경우 `thread_pool_oversubscribe` 시스템 변수에 설정한 개수만큼 추가로 더 받아들여 처리한다
    - 이 값이 너무 크면 스케줄링해야 할 스레드가 많아져서 스레드 풀이 비효율적으로 작동가능
- 스레드 그룹의 모든 스레드가 일을 처리하고 있다면 
  1. 스레드 풀은 해당 스레드 그룹에 새로운 작업 스레드를 추가할지
  2.  기존 작업 스레드가 처리를 완료할 때까지 여부 판단해야 한다
- 스레드 풀의 타이머 스테드는 주기적으로 스레드 그룹의 상태를 채크해 `thread_pool_stall_limit` 시스템 변수에 정의된 밀리초만큼 작업 스레드가 지금 처리중인 작업을 끝내지 못하면 새로운 스레드를 생성해서 스레드 그룹에 추가한다.
  - 이때 전체 스레드 풀에 있는 스레드의 개수는 `thread_pool_max_thread`시스템 변수에 설정된 개수를 넘어설 수 없다
- 모든 스레드 그룹의 스레드가 각자 작업을 처리하고 있는 상태에서 새로운 요청이 오더아도 스레드 풀은 `thread_pool_stall_limit`시간동안 기다려야 새로운 요청을 받을 수있다
  - 약간 라운드로빈 방식
  - 응답 시간이 민감한 경우 `thread_pool_stall_limit` 값을 적절히 낮춰서 사용해야 한다.
  - 변수 값을 0에 가깝게 한다면 스레드 폴을 사용하는 이유가 없기 때문에 적절히 낮춰야 한다.
- **선순위 큐**와 **후순위 큐**를 이용해 특정 트랜잭션이나 쿼리를 우선적으로 처리할 수 있는 기능 제공
  - 먼저 시작된 트랜잭션 내에 속한 SQL 을 빨리 처리하면 해당 트랜잭션이 가지고 있던 잠금이 빨리 해제되고 잠금 경합을 낮춰서 정테적인 처리 성능 향상 가능
### 4.1.10 트랜잭션 지원 메타데이터
- 딕셔너리(메타데이터) : 테이블의 구조 정보와 스토어드 프로그램 등의 정보
  - 5.7 버전 까지는 테이블 구조를 FRM 파일에 저장하고 파일 기반으로 관리
  - 생성 및 변경 작업이 트랜잭션을 지원하지 않아 비정상적으로 종료되는 경우 일관되지 않는 상태로 남는 문제 발생
    - 데이터베이스나 테이블이 깨졌다고 표현
  - 8.0 버전부터는 
    - 테이블의 구조 정보나 스토어드 프로그램 코드 관련 정보를 모두 InnoDB 테이블에 저장하도록 개선됨
    - MySQL 서버 작동에 기본적으로 필요한 테이블을 시스템 테이블이라고 함
    - 시스템 테이블을 모두 InnoDB 스토리지 엔진을 사용하도록 개선
    - 시스템 테이블과 데이터 딕셔너리 정보를 모두 모아 mysql DB 에 저장
      - mysql DB 는 통째로 mysql.ibd이름의 데이블 스페이스에 저장
      - mysql.ibd 파일명은 주의해서 사용해야 한다
    - 이제 스키마 변경 중간에 비정상적으로 종료돼더라도 스키마 변경이 완전히 성공 또는 실패로 정리됨(트랜잭션 적용)
  - MySQL 서버에서 InnoDB 스토리지 엔진을 사용하는 테이블은 메타 정보가 InnoDB 테이블 기반의 딕셔너리에 저장되지만
    - MyISAM 이나 CSV 같은 스토리지 엔진의 메타 정보는 여전히 저장공간이 필요함
      - InnoDB 이외의 스토리지 엔진을 사용하는 테이블들을 위해 SDI vkdlf tkdyd
      - *.sdi 파일은 기존의 .FRM 파일과 동일한 역할을 함
      - InnoDB 테이블들도 SDI 파일로 변환 가능
    - ibd2sdi 유틸리티를 이용하면 InnoDB 테이블 스페이스에서 스키마 정보를 추출 가능
## 4.2 InnoDB 스토리지 엔진 아키텍처
- 스토리지 엔진 중 거의 유일하게 레코드 기반 잠금 제공
  - 높은 동시성 처리 가능
  - 안정적이고 성능 뛰어남
![InnoDB](./image/InnoDB%20아키텍처.png)
### 4.2.1 프라이머리 키에 의한 클러스터링
- 모든 테이블은 기본적으로 프라이머리 키를 기준으로 클러스터링되어 저장
  - 프라이머리 키 값 순서대로 디스크에 저장
  - 모든 세컨더리 인덱스는 레코드 주소 대신 프라이머리 키의 값을 논리적 주소로 사용
  - 프라이머리 키를 이용한 레인지 스캔은 속도가 빠르다
  - 쿼리의 실행 계획에서 다른 보조 인덱스보다 프라이머리 키의 비중이 높게 설정돼있다.
- MyISAM 에서는 클러스터링 키를 지원하지 않음
### 4.2.2 외래 키 지원
- InnoDB 스토리지 엔진 레벨에서 지원하는 기능
  - 다른 스토리지 엔진에서 사용 X
- 데이터베이스 서버 운영의 불편함 때문에 외래 키를 사용하지 않는 경우 자주있지만
  - 개발 환경의 DB 에서는 좋은 가이드 역할
- 부모 테이블과 자식 테이블 모두 해당 칼럼에 인덱스 생성이 필요하고 변경 시에는 반드시 부모 테이블이나 자식 테이블에 데이터가 있는지 체크하는 작업 필요
  - 이로 인해 잠금이 여러 테이블로 전파되고 그로 인한 데드락이 발생하는 경우가 많아 개발할 떄 주의하는 것이 좋다
- 수동으로 데이터를 적재하거나 스키마 변경 등의 관리 작업이 실패할 수 있는데 외래키가 복잡하게 얽힌 경우 간단하지 않음
  - 긴급하게 조치를 취해야 하는 경우 `foreign_key_checks`시스템 변수를 OFF 로 설정하면 외래 키 관계에 대한 체크 작업을 일시적으로 멈출 수 있음
    - 부가적인 체크가 필요없어져 빠르게 처리될 수 있음
- 외래 키 체크를 일시적으로 해제했다고 해서 부모와 자식 테이블 관계가 깨진 상태로 유지되지 않음
  - 부모 테이블의 레코드를 삭제했다면 반드시 자식 테이블 레코드도 삭제한 후 외래 키 체크 기능을 활성화해야 함
- `foriegn_key_checks` 비활성화되면 부모 테이블에 대한 작업도 무시된다