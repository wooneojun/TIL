### 4.1.4 이어서
- '데이터 읽기/쓰기' 작업은 대부분 1건의 레코드 단위로 처리된다.
#### 핸들러
- MySQL 소스코드에서 넘어온 단어로 어떤 기능을 호출하기 위해 사용하는 운전대 같은 역할을 하는 객체
- MySQL 엔진은 사람역할, 각 스토리지 엔진은 자동차 역할
- MySQL 엔진은 스토리지 엔진을 조정하기 위해 **핸들러**를 사용한다.
- 다른 스토리지엔진에 대한 테이블 쿼리를 실행해도 MySQL 의 처리내용은 대부분 동일하다.
---
하나의 쿼리 작업이 여러 하위 작업으로 나뉘는데 각 하위 작업이 MySQL 영역에서 처리되는지 스토리지엔진 영역에서 처리되는지 구분할 줄 알아야한다
---
- `SHOW ENGINES;`로 MySQL 에서 지원되는 스토리지 엔진을 확인할 수 있다
- Support 표시값
  1. YES : MySQL 서버에 해당 스토리지 엔진이 포함돼있고 사용 가능으로 활성화됨
  2. DEFAULT : YES 와 동일한 상태지만 필수 스토리지 엔진(이 스토리지 엔진이 없으면 MySQL이 시작하지 않을 수있음)
  3. NO : MySQL 서버에 포함되지 않았음
  4. DISABLED : 현재 MySQL서버에는 포함됐지만 파라미터에 의해 비활성화됨
- MySQL 서버에 포함되지 않은 스토리지 엔진(Support칼럼이 NO로 표시되는)을 사용하려면 MySQL 서버를 다시 빌드(컴파일) 해야한다.
- 하지만 MySQL서버가 적절히 준비만 돼있으면 플러그인 형태로 빌드된 스토리지 엔진은 손쉽게 업그레이드 할 수 있다.
- `SHOW PLUGINS` 명령으로 스토리지 엔진 뿐 아니라 인증 및 전문 검색용 파서와 같은 플러그인도 확인할 수 있다.
### 4.1.5 컴포넌트
- MySQL 8.0 부터는 기존의 플러그인 아키텍처를 대체하기 위한 컴포넌트 아키텍처가 지원된다
  - 플러그인의 단점을 컴포넌트가 보완
  1. 플러그인은 오직 MySQL 서버와 인터페이스 할 수 있고 플러그인끼리는 통신할 수 없음
  2. 플러그인은 MySQL 서버의 변수나 함수를 직접 호출하기 때문에 안전하지 않음(캡슐화 안됨)
  3. 플러그인은 상호 의존 관계를 설정할 수 없어서 초기화 어려움
- MySQL 8.0 부터 비밀번호 검증기능이 플러그인에서 컴포넌트로 개선
  - //validate_password컴포넌트 설치 `INSTALL COMPONENT 'file://component_validate_password';`
  - // 설치된 컴포넌트 확인`SELECT * FROM mysql.component`
- 플러그인과 마찬가지로 컴포넌트도 설치하면서 새로운 시스템 변수를 설정해야 할 수 있으니 컴포넌트를 사용하기 전에 관련 매뉴얼을 살펴봐야한다.
### 4.1.6 쿼리 실행 구조
![쿼리실행구조](./image/쿼리실행구조.png)
#### 4.1.6.1 쿼리 파서
- 사용자 요청으로 들어온 쿼리 문장을 토큰으로 분리해 트리 구조로 만들어낸다
- 쿼리 문장의 **기본 문법 오류**는 이 과정에서 발견되어 오류메시지 전달
#### 4.1.6.2 전처리기
- 파서 트리를 기반으로 쿼리 문장에 구조적인 문제가 있는지 확인
- 각 토큰을 테이블 이름이나 칼럼 이름 같은 객체에 매핑해 **해당 객체의 존재 여부와 접근 권한**을 확인하는 과정 수행
#### 4.1.6.3 옵티마이저
- 사용자의 요청으로 들어온 쿼리 문장을 저렴한 비용으로 가장 빠르게 처리할지 결정
  - DBMS 의 두뇌에 해당
- 옵티마이저의 역할이 중요하고 영향 범위 또한 매우 넓다

#### 4.1.6.4 실행 엔진
- 옵티마이저가 두뇌라면 실행 엔진은 손과 발에 비유할 수 있다.
- 예를 들어
  - 옵티마이저가 GROUP BY를 처리하기 위해 임시 테이블을 사용하기로 결정함
    1. 실행 엔진이 핸들러에게 임시 테이블 만들라고 요청
    2. 다시 실행 엔진은 WHERE절에 일치하는 레코드를 읽어오라고 핸들러에게 요청
    3. 읽어온 레코드들을 1번에서 준비한 임시 테이블로 저장하라고 다시 핸들러에게 요청
    4. 데이터가 준비된 임시 테이블에서 필요한 방식으로 데이터 읽어오라고 핸들러에게 다시 요청
    5. 최종적으로 실행 엔진은 결과를 사용자나 다른 모듈로 넘김
   - 실행 엔진은 만들어진 계획대로 각 핸들러에게 요청해 받은 결과를 또 다른 핸들러의 요청의 입력으로 연결하는 역할 수행 
#### 4.1.6.5 핸들러(스토리지 엔진)
- MySQL 서버 가장 밑단에서 MySQL 실행 엔진의 요청에 따라 데이터를 디스크로 저장하고 디스크로부터 읽어오는 역할을 담당
- 스토리지 엔진의 종류에 따라 핸들러 변경된다

### 4.1.7 복제
- 복제는 매우 중요한 역할을 담당
- 별도의 장에서 다룬다

### 4.1.8 쿼리 캐시
- 빠른 응답을 필요로 하는 웹 기반의 응용 프로그램에서 매우 중요한 역할을 담당
  - SQL 실행 결과를 메모리에 캐시
  - 동일 SQL 쿼리가 실행되면 테이블 읽지 않고 즉시 결과 반환
  - 매우 빠르지만 테이블의 데이터가 변경되면 캐시 저장 결과 중 변경된 테이블과 관련된 값들 모두 삭제해야 한다.
  - **심각한 동시처리 성능 저하 유발**
  - 많은 버그의 원인이 되기도 함
- ***MySQL 8.0올라오면서 MySQL 서버 기능에서 삭제됨***
### 4.1.9 스레드 풀
- MySQL 엔터프라이즈 에디션에서 지원
  - 엔터프라이즈 에디션 대신 Percona Server 에서 스레드 풀 플러그인 형태로 제공되는 것으로 설명
- MySQL 커뮤니티 에디션은 스레드 풀 기능을 지원하지 않음
  - 커뮤니티 에디션에서 스레드 풀 기능을 사용하고 싶으면 Peercona Server 에서 스레드 풀 플러그인 라이브러리를 서버에 설치해서 사용하면된다.
- 내부적으로 사용자 요청 처리하는 스레드 개수를 줄이고
  - MySQL 서버의CPU 가 제한된 개수의 스레드 처리에만 집중할 수 있도록 해서 
  - **서버의 자원 소모를 줄이는 것이 목적**